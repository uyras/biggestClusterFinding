# Поиск энергетически выгодного кластера
Алгоритм поиска наибольшего кластера частиц с выгодным расположением относительно соседей.

*Алгоритм расчета максимального (перколяционного) кластера. Все энергии парных взаимодействия ближайших соседей каждого элемента, принадлежащего кластеру одинаковы и принимают минимальное значение из двух возможных (все связи удовлетворены). Или поиск относительного объема максимально большого зародыша новой фазы, в которой возбужденные  состояния полностью отсутствуют.*

Подходит для магнитных систем любой формы и любого размера

## Тонкая настройка
Для корректной работы алгоритма необходимо несколько переработать некоторые его части.

### Критерий "соседа"
Функция p1::isNeighbour(p2) определяет, является ли p1 соседом p2.

На примере рассматриваются решетки спинового льда,
где ближайшие соседи - перпендикулярные, соседне расположенные частицы.
То есть, их центры удалены на расстоянии меньше L (параметр решетки),
и направления их магнитных моментов перпендикулярны, т.е. скалярное произведение векторов равно нулю.

Для изменения поведения необходимо переписать функцию SuperPart::isNeighbour(p2).

Вот пример такой функции:
```c++
bool isNeighbour(SuperPart* p2) {
    return
            this->original->pos.radius(p2->original->pos).length()<d &&
            this->original->m.scalar(p2->original->m)==0 &&
            this!=p2;
}
```

### Критерий вхождения в кластер
Функция p1::isConnected(p2) определяет, является ли связь между p1 и p2 пригодной, для вхождения в кластер.
По умолчанию выставлено условие, если энергия взаимодействия двух частиц должна быть меньше 0.
(обе по полу друг с другом).

Вот пример функции по умолчанию:
```c++
bool isConnected(SuperPart* p2){
    return this->original->interact(p2->original).scalar(this->original->m)>0;
}
```

Другими словами, функция возвращает true, скалярное произведение магнитного поля,
производимого точкой p2 в точке p1 на магнитный момент точки p1 будет больше нуля
(то есть угол между вектором поля и магнитным моментом менее 90гр.)

## Применение
1. Создаем систему частиц PartArray:
```c++
PartArray *sys= new PartArray(10,10,1);
sys->dropRandom(10);
```

2. Оборачиваем его в оболочку SuperPartArray:
```c++
SuperPartArray* ssys = new SuperPartArray(sys);
```

3. Запускаем функцию getMaxCluster(), которая вернет вектор с максимальным кластером:
```c++
vector<SuperPart*> v = ssys->getMaxCluster();
cout<<v.size()<<endl;
```

## Алгоритм работы
В программе создана оболочка для класса Part (SuperPart), которая хранит в себе ссылки на соседей
и флаг, необходимый для обхода каждой частицы.
Также, создана оболочка для PartArray (SuperPartArray), которая собственно и выполняет операции над кластером.
Предполагается, что одна частица может учавствовать только в одном кластере.
Если бы она учавствовала в двух несвязанных кластерах, то она бы своим присутствием объединяла их,
и это все равно бы стал один кластер.

Далее начинаем формировать кластеры и попутно искать самый длинный из них.

1. Из числа неопределенных частиц выбираем одну, сразу добавляем ее в кластер (первая в кластере).
2. Помечаем эту частицу как "учавствующую в каком-либо кластере"
3. проходимся по ее соседям, и проверяем, есть ли из числа соседей связаные частицы
(удовлетворяющие условию связи).
4. Если есть, помечаем эту частицу как "учавствующую в каком-либо кластере",
добавляем ее в кластер, и для этой частицы выполняем шаги 3 и 4 рекурсивно.
5. Когда все элементы пройдены, считаем кластер сформированным. Далее начинаем формировать новый кластер и переходим к шагу 1
6. Повторяем шаги 1-5 до момента, пока не останется непройденных частиц.
То есть, фактически все кластеры сформированы и готовы к сравнению. Можно найти минимальный, максимальный, их сренее число и т.д.
